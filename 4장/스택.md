### 스택

---

#### 정의

- 쌓아놓은 더미



#### 구조

- **LIFO 구조 (Last - In - First - Out)** : 가장 최근의 데이터가 가장 먼저 나감

  <img src="./img/1848994ad25765da30fa8ef3684c67bc/structure of stack.jpg"  width="300" height="170">

  > push () : 스택에 데이터를 추가
  >
  > pop() : 스택에 데이터를 삭제

  

#### 예제

- **스택 추상데이터타입(ADT)**

  > * **create**(size) ::= 최대 크기가 size인 공백 스택을 생성한다.
  >
  > * **is_full**(s) ::= if(스택의 원소수 == size) return TRUE; 
  >
  >   else return FALSE;
  >
  > * **is_empty**(s) ::= if(스택의 원소수 == 0) return TRUE;
  >   else return FALSE;
  >
  > * **push**(s, item) ::= if(is_full(s)) return ERROR_STACKFULL;
  >   else 스택의 맨 위에 item을 추가한다
  > * **pop**(s) ::= if(is_empty(s)) return ERROR_STACKEMPTY;
  >   else 스택의 맨 위의 원소를 제거해서 반환한다
  > * **peek**(s) ::= if(is_empty(s)) return ERROR_STACKEMPTY;
  >   else 스택의 맨 위의 원소를 제거하지 않고 반환한다

  

#### 구현(스스로 해보기)

```c
#define _CRT_SECURE_NO_WARNINGS
#define MAX_STACK_SIZE 100
#define ERROR_STACKFULL -1
#define ERROR_STACKEMPTY -2
/*
error 목록
return -1 : ERROR_STACKFULL
return -2 : ERROR_STACKEMPTY
*/

#include <stdio.h>

typedef int element;
element stack[MAX_STACK_SIZE];	// stack 생성
int idx = -1;
int item = 0;

int is_full() {
	if (idx + 1 == MAX_STACK_SIZE)
		return 1;
	else
		return 0;
}

int is_empty() {
	if (idx == -1)
		return 1;
	else
		return 0;
}

int push(element *s, int item) {
	if (is_full())
		return ERROR_STACKFULL;

	else {
		s[idx++] = item;
		return 1;
	}
}

int pop(element* s) {
	printf("%d\n", idx);
	if (is_empty())
		return ERROR_STACKEMPTY;

	else s[idx--];
}

int peek(element* s) {
	return s[idx];
}

int main(void) {
	push(stack, 1);
	push(stack, 2);
	printf("%d", pop(stack));
}
```

> :bulb: 문제점
>
> 1. pop이 제대로 실행 안됨
> 2. 굳이 포인터를 사용해서 전역변수에 접근할 필요가 없었음
> 3. return 값 때문에 쓸데없는 반환 및 코드가 늘어남.



#### 구현 (정답 코드)

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_STACK_SIZE 100	// 스택의 최대 크기
typedef int element;		// 데이터의 자료형
element  stack[MAX_STACK_SIZE]; // 1차원 배열
int  top = -1;

// 공백 상태 검출 함수
int is_empty()
{
	return (top == -1);
}
// 포화 상태 검출 함수
int is_full()
{
	return (top == (MAX_STACK_SIZE - 1));
}
// 삽입 함수
void push(element item)
{
	if (is_full()) {
		fprintf(stderr, "스택 포화 에러\n");
		return;
	}
	else stack[++top] = item;
}
// 삭제 함수
element pop()
{
	if (is_empty()) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return stack[top--];
}
// 피크 함수
element peek()
{
	if (is_empty()) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return stack[top];
}

int main(void)
{
	push(1);
	push(2);
	push(3);
	printf("%d\n", pop());
	printf("%d\n", pop());
	printf("%d\n", pop());
	return 0;
}
```

> :bulb: 참고할 점
>
> 1. fprintf를 사용하여 함수 내에서 바로 에러 처리를 함 -> 코드의 간략화 및 순서도의 최적화
> 2. stack full과 stack empty를 판단하는 함수는 바로 비교연산을 리턴함으로서 훨씬 직관적이면서 간략한 코드가 완성됨
> 3. 전역으로 선언한  stack을 굳이 포인터로 참조하여 사용하지 않음.



#### 느낀점

이론 자체는 어렵지 않은 부분이었으나, 구현하는데 상당히 복잡하게 하였음. 생각을 조금 더 "프로그래머" 적으로 하여 효율적인 코드를 짜도록 노력해야 할 것 같음.
