### 배열 / 구조체 / 포인터



#### 배열

---

**정의** : 타입이 다른 데이터를 하나로 묶는 방법

**응용**

- 다항식 계산하기

  - 일반적인 형태
    $$
    p(x) = a_nx^n + a_{n-1}x^{n-1}+\cdots+a_1x+a_0
    $$

  - 방법

    - 다항식의 모든 항을 배열에 저장

      ```c
      #define MAX_DEGREE 101
      typedef struct{//선언
          int degree;
          float coef[MAX_DEGREE];
      }polynomial;
      polynomial a = {5,{10,0,0,0,6,3}};
      ```

      ```c
      polynomial poly_add1(polynomial A, polynomial B)
      {
      	polynomial C;// 결과 다항식
      	int Apos = 0, Bpos = 0, Cpos = 0;// 배열 인덱스 변수
      	int degree_a = A.degree;
      	int degree_b = B.degree;
      	C.degree = MAX(A.degree, B.degree); // 결과 다항식 차수
      	while (Apos <= A.degree && Bpos <= B.degree) {
      		if (degree_a > degree_b) { // A항 > B항
      			C.coef[Cpos++] = A.coef[Apos++];
      			degree_a--;
      		}
      		else if (degree_a == degree_b) { // A항 == B항
      			C.coef[Cpos++] = A.coef[Apos++] + B.coef[Bpos++];
      			degree_a--; degree_b--;
      		}
      		else {// B항 > A항
      			C.coef[Cpos++] = B.coef[Bpos++];
      			degree_b--;
      		}
      	}
      	return C;
      }
      ```

      :left_right_arrow:패딩이 발생하여 메모리가 낭비됨

      

    - 0이 아닌 항들만 배열에 저장

      ```c
      #define MAX_TERMS 101
      struct{
          float coef;
          int expon;
      }terms[MAX_TERMS];
      int avail;
      ```

      ```c
      char compare(int a, int b)
      {
      	if (a > b) return '>';
      	else if (a == b) return '=';
      	else return '<';
      }
      ```

      ```c
      void attach(float coef, int expon)
      {
      	if (avail > MAX_TERMS) {
      		fprintf(stderr, "항의 개수가 너무 많음\n");
      		exit(1);
      	}
      	terms[avail].coef = coef;
      	terms[avail++].expon = expon;
      }
      ```

      

  

#### 구조체

---

**정의** : 타입이 다른 데이터를 하나로 묶는 방법

**예시**

```c
struct studentTag{
    char name[10];
    int age;
    double gpa;
}
```

```c
struct studentTag s1;
strcpy
```

